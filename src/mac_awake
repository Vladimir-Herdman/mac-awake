#!/usr/bin/env bash

#globals
TURN_OFF_DISPLAY=false
SLEEP_AFTER=false

usage() {
    cat << USAGE_CAT
Usage: vh_later [OPTIONS [VALUE]]

Options:
  -h, --help                Show usage information for script
  -d, --displayoff          Turn off display to save power, still awake
  -s, --sleepafter          Once command finishes, enter sleep mode to save power
  -f, --for TIME            Stay awake for TIME duration
  -u, --until TIME [DATE]   Stay awake until TIME and DATE occurrs (DATE optional)

Value Explanations:
  DATE  Follows YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY format (can use '/' instead of '-')
  TIME  Follows colon format, where time starts at lowest increment and increases
        with colons (i.e. '24' passed is 24 seconds, '1:24' passed is read as 1
        minute and 24 seconds, '1:1:24' is 1 hour, 1 minute, and 24 seconds...)

        This means when used with a date, 'vh_later -u 2025-08-24 13:14:21' would
        mean 'from the current time, stay awake until the date August 24th of 2025
        and time 1:14:21 PM'

        To simplify TIME and DATE usage and avoid conversions in the head leading
        to mistakes, one can just type out the specific TIME when used with a DATE,
        so while 'vh_later -u 2025-08-24 13:14:21' is valid, so too is
        'vh_later -u 2025-08-24 1:14:21PM', or 'vh_later -u 2025-08-24 4:35:00AM'
USAGE_CAT
}

turn_time_to_seconds() {
    local time_val; time_val="$1"
    local colon_location; colon_location="$2"
    local answer; answer=$(((60**colon_location)*time_val))
    printf "%s" "$answer"
}

sleep_for() {
    local passed_time; passed_time="$1"
    local passed_time_len; passed_time_len="${#passed_time}"
    local colon_count; colon_count=0
    local -a time_parameters_arr

    local current_time_val; current_time_val=""
    for (( i=0; i<"$passed_time_len"; i++ )); do
        local ch; ch="${passed_time:$i:1}"
        current_time_val+="$ch"

        if [[ $ch == ':' ]]; then
            time_parameters_arr["$colon_count"]="${current_time_val%:}" #take one character off end
            current_time_val=""
            ((++colon_count))
        fi
        if [[ $((i+1)) -eq "$passed_time_len" ]]; then
            time_parameters_arr["$colon_count"]="$current_time_val"
            current_time_val=""
        fi
    done

    local seconds; seconds=0
    for word in "${time_parameters_arr[@]}"; do
        ((seconds+=$(turn_time_to_seconds "$word" "$colon_count")))
        ((--colon_count))
    done

    printf "awake for %s seconds" "$seconds"
    if [[ $((seconds/60)) -ne 0 ]]; then
        printf " (about %s minutes and %s seconds)\n" "$((seconds/60))" "$((seconds%60))"
    else
        printf "\n"
    fi

    if [[ "$TURN_OFF_DISPLAY" = true ]]; then pmset displaysleepnow; fi
    caffeinate -t "$seconds"
    sleep 0.5
    if [[ "$SLEEP_AFTER" = true ]]; then pmset sleepnow; fi
}

improper_time(){
    printf "%s\n" "Improper TIME format given, should be for example 1pm, 1:30am, 14:39:12, 3:42:00pm"
}
clean_time() {
    local time="$1"
    local time_pmam="${time: -2}"; time_pmam="${time_pmam,,}" #last two; make lowercase

    #clean out time given
    if [[ "$time_pmam" = "am" || "$time_pmam" = "pm" ]]; then
        time="${time//pm/}"
        time="${time//am/}"
    fi

    #break apart time sections and normalize
    local h m s; IFS=':' read -r h m s <<< "$time"
    if [[ "$time_pmam" = 'pm' && "$h" != '12' ]]; then h="$(( h + 12 ))"; fi
    m="${m:-0}" #if no value provided, just be 0
    s="${s:-0}"

    #confirm length before continuing
    local colon_count="${time//:/}"; colon_count="$(( ${#time} - ${#colon_count} ))"
    local time_len="${#time}"
    case "$colon_count" in
        0) #1pm, 12pm, 8am
            if [[ "$time_len" -gt 2 ]]; then return 1; fi;;

        1) #1:20, 12:30pm, 8:21am
            if [[ "$time_len" -gt 5 ]]; then return 1; fi;;

        2) #1:0:0, 1:00:00, 12:34:4, 8:41:23pm
            if [[ "$time_len" -gt 8 ]]; then return 1; fi;;

        *) return 1;;
    esac

    #return normalized time
    printf "%02d:%02d:%02d" "$h" "$m" "$s" 
}
improper_date() {
    printf "%s" "Not a valid date format, should be YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY"
}
clean_date() {
    local date="$1"

    #basic cleaning
    if [[ -z "$date" ]]; then return 0; fi
    date=${date//\//-} #parameter expansion -> substitute / with -

    #fill with 0's if single num
    local y m d ;IFS="-" read -r y m d <<< "$date"
    date="$(printf "%02d-%02d-%02d" "$y" "$m" "$d")"

    #confirm form YYYY-MM-DD
    if date -j -f "%Y-%m-%d" "$date" >/dev/null 2>&1; then
        true
    elif date -j -f "%m-%d-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%m-%d-%Y" "$date" +"%Y-%m-%d")"
    elif date -j -f "%d-%m-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%d-%m-%Y" "$date" +"%Y-%m-%d")"
    else
        return 1
    fi

    printf "%s" "$date"
}
until_time() {
    #clean passed values
    local passed_time; if ! passed_time="$(clean_time "$1")"; then
        improper_time; exit 1
    fi
    local passed_date; if ! passed_date="$(clean_date "$2")"; then
        improper_date; exit 1;
    fi

    #get current date time for calculations
    local cur_date; cur_date="$(date +"%Y-%m-%d")" #2025-08-31
    local cur_time; cur_time="$(date +"%H:%M:%S")" #18:42:20 for 6:42PM (military time)
    if [[ -z "$passed_date" ]]; then passed_date="$cur_date"; fi

    #get difference in seconds between passed time and now
    local cur_ts passed_ts
    cur_ts=$(date -j -f "%Y-%m-%d %H:%M:%S" "$cur_date $cur_time" +"%s")
    passed_ts=$(date -j -f "%Y-%m-%d %H:%M:%S" "$passed_date $passed_time" +"%s")
    local dif_seconds="$(( passed_ts - cur_ts ))"

    if [[ "$TURN_OFF_DISPLAY" = true ]]; then pmset displaysleepnow; fi
    printf "awake until %s %s" "$passed_date" "$passed_time"
    if [[ $((dif_seconds/60)) -ne 0 ]]; then
        printf " (about %s minutes and %s seconds)\n" "$((dif_seconds/60))" "$((dif_seconds%60))"
    else
        printf " (about %s seconds)\n" "$dif_seconds"
    fi
    caffeinate -t "$dif_seconds"
    sleep 0.5
    if [[ "$SLEEP_AFTER" = true ]]; then pmset sleepnow; fi
}

main() {
    if [[ "$#" -eq 0 ]]; then printf "%s\n" "No command line options passed"; exit 1; fi

    #check options first to see if globals change
    for arg in "$@"; do
        case "$arg" in
            --displayoff | -d)
                TURN_OFF_DISPLAY=true
                ;;

            --sleepafter | -s)
                SLEEP_AFTER=true
                ;;

            *) ;;
        esac
    done

    #main loop usage for options
    local count=0
    for arg in "$@"; do
        ((++count))
        case "$arg" in 
            --help | -h)
                usage
                exit 0;;

            --displayoff | -d)
                ;;

            --sleepafter | -s)
                ;;

            --for | -f)
                local arg_after=$((count+1)); arg_after="${!arg_after}"
                if [[ -z "$arg_after" ]]; then printf "%s\n" "No value passed to given option"; exit 1; fi
                sleep_for "$arg_after";
                exit 0;;

            --until | -u) 
                local arg_after=$((count+1)); arg_after="${!arg_after}"
                local arg_even_after=$((count+2)); arg_even_after="${!arg_even_after}"
                if [[ -z "$arg_after" ]]; then printf "%s\n" "No values passed to given option"; exit 1; fi
                until_time "$arg_after" "$arg_even_after"
                exit 0;;

            *) printf "%s\n" 'invalid command line option'; exit 1;;
        esac
    done
}

main "$@"
