#!/usr/bin/env bash
#The first argument should be the time at which to stop caffeinate

usage() {
    cat << USAGE_CAT
Usage: vh_later [OPTIONS [VALUE]]

Options:
  -h, --help                Show usage information for script
  -f, --for TIME            Stay awake for TIME duration
  -u, --until TIME [DATE]   Stay awake until TIME and DATE occurrs (DATE optional)

Value Explanations:
  DATE  Follows YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY format (can use '/' instead of '-')
  TIME  Follows colon format, where time starts at lowest increment and increases
        with colons (i.e. '24' passed is 24 seconds, '1:24' passed is read as 1
        minute and 24 seconds, '1:1:24' is 1 hour, 1 minute, and 24 seconds...)

        This means when used with a date, 'vh_later -u 2025-08-24 13:14:21' would
        mean 'from the current time, stay awake until the date August 24th of 2025
        and time 1:14:21 PM'

        To simplify TIME and DATE usage and avoid conversions in the head leading
        to mistakes, one can just type out the specific TIME when used with a DATE,
        so while 'vh_later -u 2025-08-24 13:14:21' is valid, so too is
        'vh_later -u 2025-08-24 1:14:21PM', or 'vh_later -u 2025-08-24 4:35:00AM'
USAGE_CAT
    exit 0
}

turn_time_to_seconds() {
    local time_val; time_val="$1"
    local colon_location; colon_location="$2"
    local answer; answer=$(((60**colon_location)*time_val))
    printf "%s" "$answer"
}

sleep_for() {
    local passed_time; passed_time="$1"
    local passed_time_len; passed_time_len="${#passed_time}"
    local colon_count; colon_count=0
    local -a time_parameters_arr

    local current_time_val; current_time_val=""
    for (( i=0; i<"$passed_time_len"; i++ )); do
        local ch; ch="${passed_time:$i:1}"
        current_time_val+="$ch"

        if [[ $ch == ':' ]]; then
            time_parameters_arr["$colon_count"]="${current_time_val%:}" #take one character off end
            current_time_val=""
            ((++colon_count))
        fi
        if [[ $((i+1)) -eq "$passed_time_len" ]]; then
            time_parameters_arr["$colon_count"]="$current_time_val"
            current_time_val=""
        fi
    done

    local seconds; seconds=0
    for word in "${time_parameters_arr[@]}"; do
        ((seconds+=$(turn_time_to_seconds "$word" "$colon_count")))
        ((--colon_count))
    done

    printf "sleeping for %s seconds" "$seconds"
    if [[ $((seconds/60)) -ne 0 ]]; then
        printf " (about %s minutes and %s seconds)\n" "$((seconds/60))" "$((seconds%60))"
    else
        printf "\n"
    fi

    caffeinate -t "$seconds"
    sleep 0.5
    pmset sleepnow
}

clean_time() {
    local time="$1"

    if [[ -z "$time" ]]; then return; fi

    printf "%s" "$time"
}
clean_date() {
    local date="$1"

    #basic cleaning
    if [[ -z "$date" ]]; then return; fi
    if [[ "$date" = */* ]]; then date="$(printf "%s" "$date" | sed "s/\//-/g")"; fi

    #fill with 0's if single num
    local val1 val2 val3 ;IFS="-" read -r val1 val2 val3 <<< "$date"
    for i in val1 val2 val3; do
        local ival="${!i}"
        if [[ "${#ival}" -eq 1 ]]; then printf -v "$i" "%02d" "$ival"; fi
    done
    date="$val1-$val2-$val3"

    #confirm form YYYY-MM-DD
    if date -j -f "%Y-%m-%d" "$date" >/dev/null 2>&1; then
        true
    elif date -j -f "%m-%d-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%m-%d-%Y" "$date" +"%Y-%m-%d")"
    elif date -j -f "%d-%m-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%d-%m-%Y" "$date" +"%Y-%m-%d")"
    else
        printf "%s" "Not a valid date format, should be YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY"
        exit 1
    fi

    printf "%s" "$date"
}
until_time() {
    #TODO: Look to usage (-h | --help) TIME value explanation for overall idea of this one - (LINE 15)
    local passed_time; passed_time="$(clean_time "$1")"
    local passed_date; passed_date="$(clean_date "$2")"
    echo "$passed_date"

    local cur_date; cur_date="$(date +"%Y-%m-%d")" #2025-08-31
    local cur_time; cur_time="$(date +"%H:%M:%S")" #18:42:20 for 6:42PM (military time)

    if [[ -n "$passed_time" ]]; then
        if [[ -n "$passed_date" ]]; then
            #date and time passed
            true
        else
            #just time passed
            true
        fi
    fi

    #local cur_date=
    #local cur_time=
}

main() {
    if [[ "$#" -eq 0 ]]; then printf "%s\n" "No command line options passed"; exit 1; fi

    for arg in "$@"; do
        case "$arg" in 
            --help | -h)
                usage;;

            --for | -f)
                if [[ -z "$2" ]]; then printf "%s\n" "No value passed to given option"; exit 1; fi
                sleep_for "$2";
                exit 0;;

            --until | -u) 
                if [[ -z "$2" ]]; then printf "%s\n" "No values passed to given option"; exit 1; fi
                until_time "$2" "$3"
                exit 0;;

            *) printf "%s\n" 'invalid command line option'; exit 1;;
        esac
    done
}

main "$@"
