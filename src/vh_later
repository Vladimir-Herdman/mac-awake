#!/usr/bin/env bash
#The first argument should be the time at which to stop caffeinate

usage() {
    cat << USAGE_CAT
Usage: vh_later [OPTIONS [VALUE]]

Options:
  -h, --help                Show usage information for script
  -f, --for TIME            Stay awake for TIME duration
  -u, --until TIME [DATE]   Stay awake until TIME and DATE occurrs (DATE optional)

Value Explanations:
  DATE  Follows YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY format (can use '/' instead of '-')
  TIME  Follows colon format, where time starts at lowest increment and increases
        with colons (i.e. '24' passed is 24 seconds, '1:24' passed is read as 1
        minute and 24 seconds, '1:1:24' is 1 hour, 1 minute, and 24 seconds...)

        This means when used with a date, 'vh_later -u 2025-08-24 13:14:21' would
        mean 'from the current time, stay awake until the date August 24th of 2025
        and time 1:14:21 PM'

        To simplify TIME and DATE usage and avoid conversions in the head leading
        to mistakes, one can just type out the specific TIME when used with a DATE,
        so while 'vh_later -u 2025-08-24 13:14:21' is valid, so too is
        'vh_later -u 2025-08-24 1:14:21PM', or 'vh_later -u 2025-08-24 4:35:00AM'
USAGE_CAT
    exit 0
}

turn_time_to_seconds() {
    local time_val; time_val="$1"
    local colon_location; colon_location="$2"
    local answer; answer=$(((60**colon_location)*time_val))
    printf "%s" "$answer"
}

sleep_for() {
    local passed_time; passed_time="$1"
    local passed_time_len; passed_time_len="${#passed_time}"
    local colon_count; colon_count=0
    local -a time_parameters_arr

    local current_time_val; current_time_val=""
    for (( i=0; i<"$passed_time_len"; i++ )); do
        local ch; ch="${passed_time:$i:1}"
        current_time_val+="$ch"

        if [[ $ch == ':' ]]; then
            time_parameters_arr["$colon_count"]="${current_time_val%:}" #take one character off end
            current_time_val=""
            ((++colon_count))
        fi
        if [[ $((i+1)) -eq "$passed_time_len" ]]; then
            time_parameters_arr["$colon_count"]="$current_time_val"
            current_time_val=""
        fi
    done

    local seconds; seconds=0
    for word in "${time_parameters_arr[@]}"; do
        ((seconds+=$(turn_time_to_seconds "$word" "$colon_count")))
        ((--colon_count))
    done

    printf "sleeping for %s seconds" "$seconds"
    if [[ $((seconds/60)) -ne 0 ]]; then
        printf " (about %s minutes and %s seconds)\n" "$((seconds/60))" "$((seconds%60))"
    else
        printf "\n"
    fi

    caffeinate -t "$seconds"
    sleep 0.5
    pmset sleepnow
}

improper_time(){
    printf "%s\n" "Improper TIME format given, should be for example 1pm, 1:30am, 14:39:12, 3:42:00pm"
}
clean_time() {
    local time="$1"
    local time_pmam="${time: -2}"; time_pmam="${time_pmam,,}" #last two; make lowercase

    #clean out time given
    if [[ "$time_pmam" = "am" || "$time_pmam" = "pm" ]]; then
        time="${time//pm/}"
        time="${time//am/}"
    fi

    #normalize time format into military style, count ':' occurrences
    local colon_count="${time//:/}"; colon_count="$(( ${#time} - ${#colon_count} ))"
    local time_len="${#time}"

    local -a time_arr; IFS=":" read -ra time_arr <<< "$time"

    local h m s
    h="${time_arr[0]}"
    m="${time_arr[1]:-0}" #if no value provided, just be 0
    s="${time_arr[2]:-0}"

    if [[ "$time_pmam" = 'pm' && "$h" != '12' ]]; then h="$(( h + 12 ))"; fi

    case "$colon_count" in
        0) #1pm, 12pm, 8am
            if [[ "$time_len" -gt 2 ]]; then return 1; fi;;

        1) #1:20, 12:30pm, 8:21am
            if [[ "$time_len" -gt 5 ]]; then return 1; fi;;

        2) #1:0:0, 1:00:00, 12:34:4, 8:41:23pm
            if [[ "$time_len" -gt 8 ]]; then return 1; fi;;

        *) return 1;;
    esac

    time="$(printf "%02d:%02d:%02d" "$h" "$m" "$s")" 
    printf "%s" "$time"
}
improper_date() {
    printf "%s" "Not a valid date format, should be YYYY-MM-DD, MM-DD-YYYY, or DD-MM-YYYY"
}
clean_date() {
    local date="$1"

    #basic cleaning
    if [[ -z "$date" ]]; then return 0; fi
    date=${date//\//-} #parameter expansion -> substitute / with -

    #fill with 0's if single num
    local val1 val2 val3 ;IFS="-" read -r val1 val2 val3 <<< "$date"
    for i in val1 val2 val3; do
        local ival="${!i}"
        if [[ "${#ival}" -eq 1 ]]; then printf -v "$i" "%02d" "$ival"; fi
    done
    date="$val1-$val2-$val3"

    #confirm form YYYY-MM-DD
    if date -j -f "%Y-%m-%d" "$date" >/dev/null 2>&1; then
        true
    elif date -j -f "%m-%d-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%m-%d-%Y" "$date" +"%Y-%m-%d")"
    elif date -j -f "%d-%m-%Y" "$date" >/dev/null 2>&1; then
        date="$(date -j -f "%d-%m-%Y" "$date" +"%Y-%m-%d")"
    else
        return 1
    fi

    printf "%s" "$date"
}
until_time() {
    #TODO: Look to usage (-h | --help) TIME value explanation for overall idea of this one - (LINE 15)
    local passed_time; if ! passed_time="$(clean_time "$1")"; then
        improper_time; exit 1
    fi
    echo "$passed_time"; exit
    local passed_date; if ! passed_date="$(clean_date "$2")"; then
        improper_date; exit 1;
    fi

    local cur_date; cur_date="$(date +"%Y-%m-%d")" #2025-08-31
    local cur_time; cur_time="$(date +"%H:%M:%S")" #18:42:20 for 6:42PM (military time)

    if [[ -z "$passed_date" ]]; then passed_date="$cur_date"; fi

    #TODO:
        #here, we have standardized date and times for what was passed, and what it is currently
        #calculate now the differenc in time, get it in seconds, and then caffeinate sleep

    #printf "sleeping until %s %s" "$passed_date" "$passed_time"
    #if [[ $((seconds/60)) -ne 0 ]]; then
    #    printf " (about %s minutes and %s seconds)\n" "$((seconds/60))" "$((seconds%60))"
    #else
    #    printf " (about %s seconds)\n" "$seconds"
    #fi
    #caffeinate -t "$seconds"
    #sleep 0.5
    #pmset sleepnow
}

main() {
    if [[ "$#" -eq 0 ]]; then printf "%s\n" "No command line options passed"; exit 1; fi

    for arg in "$@"; do
        case "$arg" in 
            --help | -h)
                usage;;

            --for | -f)
                if [[ -z "$2" ]]; then printf "%s\n" "No value passed to given option"; exit 1; fi
                sleep_for "$2";
                exit 0;;

            --until | -u) 
                if [[ -z "$2" ]]; then printf "%s\n" "No values passed to given option"; exit 1; fi
                until_time "$2" "$3"
                exit 0;;

            *) printf "%s\n" 'invalid command line option'; exit 1;;
        esac
    done
}

main "$@"
